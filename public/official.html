<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Official Chat (True E2EE)</title>
<style>
body{font-family:Arial;margin:20px;}
.messages{
border:1px solid #ccc;
height:400px;
overflow-y:scroll;
padding:5px;
margin-bottom:10px;
}
input{width:70%;padding:5px;}
button{padding:5px 10px;}
.convo-list{
border:1px solid #aaa;
padding:10px;
margin-bottom:15px;
max-height:200px;
overflow-y:auto;
}
.convo-item{
padding:5px;
cursor:pointer;
border-bottom:1px solid #eee;
}
.convo-item:hover{
background:#f2f2f2;
}
</style>
</head>

<body>

<script>
// üîê LOGIN PROTECTION
const TOKEN = localStorage.getItem("JWT_TOKEN");
const DEPT  = localStorage.getItem("DEPARTMENT");

if(!TOKEN || !DEPT){
    alert("Session expired. Please login again.");
    window.location.href="login.html";
}
</script>

<h2>Official Chat (True E2EE)</h2>
<button onclick="logout()">Logout</button>
<hr>

<h3>Conversations</h3>
<div class="convo-list" id="conversationList"></div>

<h3>Messages</h3>
<div class="messages" id="messages"></div>

<label>Reply Token:</label>
<input id="replyTokenInput" placeholder="Reply token..." />
<br><br>

<input id="msg" placeholder="Reply to citizen..." />
<button onclick="sendMessage()">Send</button>

<script>

let ws;
let departmentPrivateKey;
let departmentPublicKeyHex;
let conversationPublicKeys = {};
let currentReplyToken = null;

// --------------------
// CONNECT WEBSOCKET
// --------------------
const protocol = location.protocol === "https:" ? "wss:" : "ws:";
ws = new WebSocket(`${protocol}//${location.host}/official?token=${TOKEN}&dept=${DEPT}`);

ws.onopen = async () => {

    console.log("Official connected");

    const publicKeyHex = await initDepartmentKey();

    // üî• SEND PUBLIC KEY TO SERVER
    ws.send(JSON.stringify({
        type: "departmentPublicKey",
        department: DEPT,
        publicKey: publicKeyHex
    }));
};

// --------------------
// RECEIVE MESSAGE
// --------------------
ws.onmessage = async (e) => {

    const msg = JSON.parse(e.data);

    // Conversation list (WhatsApp style)
    if(msg.type === "conversationList"){
        renderConversationList(msg.conversations);
        return;
    }

    const messagesEl = document.getElementById("messages");

    // History load
    if(msg.chatType === "history"){

    messagesEl.innerHTML = "";

    // üî• FIRST PASS ‚Äî collect citizen public key
    // üîê Get citizen key from conversation root
// üîê Store citizen key sent from server
if(msg.citizenPublicKey){
    conversationPublicKeys[msg.replyToken] = msg.citizenPublicKey;
}

    // üî• SECOND PASS ‚Äî decrypt safely
    // üî• SECOND PASS ‚Äî decrypt safely
for(const m of msg.messages){

    // üîê VERY IMPORTANT FIX
    m.replyToken = msg.replyToken;

    let text;

    try {
        text = await decryptMessage(m);
    } catch(err) {
        console.log("Decryption failed:", err);
        text = "[Decryption Failed]";
    }

    messagesEl.innerHTML += `
        <b>${m.from === "citizen" ? "Citizen" : "You"}:</b>
        ${text}
        <br><small>${new Date(m.timestamp).toLocaleTimeString()}</small><br><br>
    `;
}

    messagesEl.scrollTop = messagesEl.scrollHeight;
    return;
}

    // Live message
    if(msg.chatType === "cto"){

        if(msg.citizenPublicKey){
            conversationPublicKeys[msg.replyToken] = msg.citizenPublicKey;
        }

        const text = await decryptMessage(msg);

        messagesEl.innerHTML += `
            <b>${msg.chatType === "cto" ? "Citizen" : "You"}:</b>
            ${text}
            <br><small>${new Date(msg.timestamp).toLocaleTimeString()}</small><br><br>
        `;

        messagesEl.scrollTop = messagesEl.scrollHeight;

        currentReplyToken = msg.replyToken;
        document.getElementById("replyTokenInput").value = msg.replyToken;
    }
};

// --------------------
// SEND MESSAGE
// --------------------
async function sendMessage(){

    const input = document.getElementById("msg");
    const replyToken = document.getElementById("replyTokenInput").value.trim();

    if(!input.value.trim()) return;
    if(!replyToken) return alert("Select conversation first!");

    const citizenPublicKeyHex = conversationPublicKeys[replyToken];
    if(!citizenPublicKeyHex) return alert("No key found for this conversation.");

    const citizenPublicKey = await crypto.subtle.importKey(
        "raw",
        hexToBuffer(citizenPublicKeyHex),
        { name: "ECDH", namedCurve: "P-256" },
        false,
        []
    );

    const sharedSecret = await crypto.subtle.deriveBits(
        { name: "ECDH", public: citizenPublicKey },
        departmentPrivateKey,
        256
    );

    const aesKey = await crypto.subtle.importKey(
        "raw",
        await crypto.subtle.digest("SHA-256", sharedSecret),
        { name: "AES-GCM" },
        false,
        ["encrypt"]
    );

    const iv = crypto.getRandomValues(new Uint8Array(12));

    const encrypted = await crypto.subtle.encrypt(
        { name: "AES-GCM", iv },
        aesKey,
        new TextEncoder().encode(input.value)
    );

    ws.send(JSON.stringify({
    chatType: "otc",
    department: DEPT,
    replyToken,
    ciphertext: bufferToHex(encrypted),
    iv: bufferToHex(iv),
    officialPublicKey: localStorage.getItem("DEPT_PUBLIC_KEY_" + DEPT),
    timestamp: Date.now()
}));
    const messagesEl = document.getElementById("messages");

messagesEl.innerHTML += `
    <b>You:</b> ${input.value}
    <br><small>${new Date().toLocaleTimeString()}</small><br><br>
`;

messagesEl.scrollTop = messagesEl.scrollHeight;
    input.value="";
}

// --------------------
// DECRYPT MESSAGE
// --------------------
async function decryptMessage(data){

    if(!data.ciphertext) return "[Invalid]";

    const citizenPublicKeyHex =
    data.citizenPublicKey ||
    conversationPublicKeys[data.replyToken];
    if(!citizenPublicKeyHex) return "[Missing Key]";

    const citizenPublicKey = await crypto.subtle.importKey(
        "raw",
        hexToBuffer(citizenPublicKeyHex),
        { name: "ECDH", namedCurve: "P-256" },
        false,
        []
    );

    const sharedSecret = await crypto.subtle.deriveBits(
        { name: "ECDH", public: citizenPublicKey },
        departmentPrivateKey,
        256
    );

    const aesKey = await crypto.subtle.importKey(
        "raw",
        await crypto.subtle.digest("SHA-256", sharedSecret),
        { name: "AES-GCM" },
        false,
        ["decrypt"]
    );

    const decrypted = await crypto.subtle.decrypt(
        { name: "AES-GCM", iv: hexToBuffer(data.iv) },
        aesKey,
        hexToBuffer(data.ciphertext)
    );

    return new TextDecoder().decode(decrypted);
}

// --------------------
// PERSISTENT DEPARTMENT KEY
// --------------------
async function initDepartmentKey(){

    const storedPrivate = localStorage.getItem("DEPT_PRIVATE_KEY_" + DEPT);
    const storedPublic  = localStorage.getItem("DEPT_PUBLIC_KEY_" + DEPT);

    if(storedPrivate && storedPublic){

        departmentPrivateKey = await crypto.subtle.importKey(
            "pkcs8",
            hexToBuffer(storedPrivate),
            { name: "ECDH", namedCurve: "P-256" },
            false,
            ["deriveBits"]
        );

        return storedPublic;
    }

    const keyPair = await crypto.subtle.generateKey(
        { name: "ECDH", namedCurve: "P-256" },
        true,
        ["deriveBits"]
    );

    departmentPrivateKey = keyPair.privateKey;

    const privateRaw = await crypto.subtle.exportKey("pkcs8", keyPair.privateKey);
    const publicRaw  = await crypto.subtle.exportKey("raw", keyPair.publicKey);

    const privateHex = bufferToHex(privateRaw);
    const publicHex  = bufferToHex(publicRaw);

    localStorage.setItem("DEPT_PRIVATE_KEY_" + DEPT, privateHex);
localStorage.setItem("DEPT_PUBLIC_KEY_" + DEPT, publicHex);

    return publicHex;
}

// --------------------
// CONVERSATION LIST
// --------------------
function renderConversationList(conversations){

    const listEl = document.getElementById("conversationList");
    listEl.innerHTML = "";

    conversations.sort((a,b) => b.lastMessageTime - a.lastMessageTime);

    conversations.forEach(c => {

        const div = document.createElement("div");
        div.className = "convo-item";

        div.innerHTML = `
            <b>${c.replyToken.substring(0,10)}...</b>
            <br>
            Unread: ${c.unreadCount}
        `;

        div.onclick = () => {
            loadConversation(c.replyToken);
        };

        listEl.appendChild(div);
    });
}

// --------------------
// LOAD HISTORY
// --------------------
function loadConversation(replyToken){

    document.getElementById("replyTokenInput").value = replyToken;

    ws.send(JSON.stringify({
        chatType: "loadHistory",
        department: DEPT,
        replyToken
    }));
}

// --------------------
// LOGOUT
// --------------------
function logout(){
    ws.close();
    localStorage.removeItem("JWT_TOKEN");
    localStorage.removeItem("DEPARTMENT");
    window.location.href="login.html";
}

// --------------------
// HELPERS
// --------------------
function bufferToHex(buffer){
    return [...new Uint8Array(buffer)]
        .map(b => b.toString(16).padStart(2, "0"))
        .join("");
}

function hexToBuffer(hex){
    const bytes = new Uint8Array(hex.length / 2);
    for(let i = 0; i < bytes.length; i++){
        bytes[i] = parseInt(hex.substr(i*2, 2), 16);
    }
    return bytes;
}

</script>

</body>
</html>